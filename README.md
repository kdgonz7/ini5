# INI5

An INI parser library written in Zig, for Zig. Optimizations and benchmarks
shall be provided soon. Converts INI into AST format, supports sections, section
breaks, and simple assignments and values. Comes with a eco-efficient, thread 
and memory safe program "inivisitor", toview the trees and values generated by 
the INI5 library.

## Synopsis
* **Secure**
    * INI5 can handle bad inputs without any crashes, memory violations, or high memory consumption. Under
        heavy loads, INI5 strikes the perfect balance between performance and memory-safety.
* **Battle-Tested and Memory Safe**
    * INI5 is tested against the most random, unpredictable, and corrupted files, and survived each input
        with low memory consumption and efficient error communication. Don't believe me? Try it for yourself!
        Build the `inivisitor` program, and run it against `samples/overtly_corrupted_file.ini`. Not even the
        standing man codepoint can penetrate INI5.
* **Easy-to-read codebase**
    * Another goal of INI5 is to be easy to read for people reading the codebase with no experience in either
        Parsing or in the Zig language.
* **Maintainable**
    * With over **20 tests** and **10+ sample files** that are applicable to real-world applications,
        INI5 is made to handle any inputs in a structured and realistic way, parsing the INI structure into
        a syntax tree which can then be read raw or converted into sections automatically.

## Visitor

```zig
var c_alloc = std.heap.ArenaAllocator.init(std.heap.c_allocator);
defer c_alloc.deinit();

const arena = c_alloc.allocator();

const sections = parseFile(arena, "hello.ini") catch |err| {
    std.log.err("Failed to read file: '{s}'", .{args[1]});
    std.log.err("({any})", .{err});
    std.process.exit(1);
};

var section_list = sections.iterator();

while (section_list.next()) |item| {
    visit(item.key_ptr.*, item.value_ptr.*, 0);
}

fn visit(name: []const u8, section: INISection, indent: usize) {
    for (0..indent) |_| {
        std.log.info(" ", .{});
    }

    std.log.info("section {s}", .{name});

    var iterator = section.variables.iterator();
    while (iterator.next()) |assignment| {
        std.log.info("   | assignment {s}", .{assignment.key_ptr.*});
        std.log.info("   | value type {any}", .{assignment.value_ptr.*});
    }
}
```
